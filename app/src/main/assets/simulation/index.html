<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
    <title>ê²€ì‚¬ êµ¬ë™ ë¡œë´‡ ì‹œë®¬ë ˆì´ì…˜</title>
    <style>
        html,body{margin:0;height:100%;background:#0f0f12;overflow:hidden}
        #c{width:100%;height:100%;display:block}
        .hud{
            position:fixed;left:10px;top:10px;color:#cfd8dc;
            font:17px/1.4 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans KR",Arial,sans-serif;
            background:rgba(0,0,0,.35);padding:8px 10px;border-radius:8px
        }
    </style>
    <script src="./libs/three.min.js"></script>
    <script src="./libs/OrbitControls.js"></script>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">
    <div>ì…ë ¥ë‹¨ìœ„: mm (ë‚´ë¶€ m + ìŠ¤ì¼€ì¼, ZëŠ” 2ë°° ì‹œê°í™”)</div>
    <div id="poseText"><b>x:0 y:0 z:0 s1:0Â° s2:0Â° s3:0Â°</b></div>
</div>

<script>
    /* ====================== ìƒìˆ˜/í—¬í¼ ====================== */
    const MM_TO_M = 1/1000;

    // ì‹¤ì œ ì‘ì—… ì˜ì—­(mm)
    const RAW_X_MM       = 25000; // X ì‘ì—… ë²”ìœ„
    const RAW_Y_MM       = 44000; // Y ì‘ì—… ë²”ìœ„
    const RAW_Z_WORK_MM  = 3500;  // ë ˆì¼/ì‘ì—… Z ë²”ìœ„ (ì‹¤ì œ)
    const RAW_Z_FRAME_MM = 5000;  // í”„ë ˆì„ ê¹Šì´ Z (ì‹¤ì œ)

    // Zì¶•ì„ í™”ë©´ì—ì„œ 2ë°°ë¡œ ëŠ˜ë ¤ ë³´ì´ê²Œ
    const Z_VISUAL_SCALE = 2; // 2ë°°

    // ì „ì²´ ëª¨ë¸ì„ í™”ë©´ì—ì„œ ì–¼ë§ˆë‚˜ í¬ê²Œ ë³¼ì§€ (m)
    const TARGET_MAX = 1.5;       // ìµœëŒ€ ì¹˜ìˆ˜ë¥¼ 1.5m ì •ë„ë¡œ ì¶•ì†Œ

    // ì‹¤ì œ ìµœëŒ€ ê¸¸ì´(m) â€“ ZëŠ” ì‹œê°í™” ìŠ¤ì¼€ì¼ ë°˜ì˜
    const RAW_MAX_M = Math.max(
        RAW_X_MM,
        RAW_Y_MM,
        RAW_Z_FRAME_MM * Z_VISUAL_SCALE
    ) * MM_TO_M;

    // ì „ì²´ ìŠ¤ì¼€ì¼ ë¹„ìœ¨
    const SCENE_SCALE = TARGET_MAX / RAW_MAX_M;

    // ì”¬ ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•  ì¶•ì†Œëœ í¬ê¸°(m) (ë¡œë´‡ì´ ì‹¤ì œë¡œ ì›€ì§ì´ëŠ” ë‚´ë¶€ ì‘ì—… ì˜ì—­)
    const SIZE_X = RAW_X_MM                 * MM_TO_M * SCENE_SCALE;              // X ë‚´ë¶€ ì‘ì—… ê¸¸ì´
    const SIZE_Y = RAW_Y_MM                 * MM_TO_M * SCENE_SCALE;              // Y ë‚´ë¶€ ì‘ì—… ë†’ì´
    const SIZE_Z = RAW_Z_FRAME_MM * Z_VISUAL_SCALE * MM_TO_M * SCENE_SCALE;       // Z í”„ë ˆì„ ê¹Šì´(2ë°° ì ìš©)

    // ğŸ”¸ í”„ë ˆì„ ë¹” ë‘ê»˜
    const FRAME_THICK = 0.025; // 2.5cm

    // ğŸ”¸ ìƒë¶€ì— ì—¬ìœ ë¡œ ë” ì˜¬ë¦´ ë†’ì´ (ê¸°ë‘¥ì„ ë” í‚¤ìš°ê¸° ìœ„í•¨)
    const EXTRA_TOP = 0.08; // 10cm ì •ë„ ì—¬ìœ  (í•„ìš”í•˜ë©´ ë” í‚¤ì›Œë„ ë¨)

    // ë ˆì¼ ê¸¸ì´(ì‹¤ì œ 3500 * 2ë°° ì‹œê°í™” = 7000ì— ë”± ë§ê²Œ)
    const RAIL_LEN_M = RAW_Z_WORK_MM * Z_VISUAL_SCALE * MM_TO_M * SCENE_SCALE;
    const RAIL_Z_CENTER = RAIL_LEN_M / 2;  // 0 ~ RAIL_LEN_M ë²”ìœ„ ì¤‘ì•™

    // ì•”/ê´€ì ˆ ê¸¸ì´ (ì›”ë“œ ìŠ¤ì¼€ì¼ê³¼ ë¬´ê´€í•˜ê²Œ ìƒëŒ€ í¬ê¸° ìœ ì§€ìš©)
    const LINK_L1 = 0.18;
    const LINK_L2 = LINK_L1 / 2.4;
    const L2_THICK = 0.02 * 1.7;
    const L1_THICK = 0.025 * 1.7;

    const deg2rad = THREE.MathUtils.degToRad;
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

    /* ==== ê°ë„ ë³´ì •ìš© ì ˆëŒ€ ë³€ìˆ˜ (í˜„ì¥ì—ì„œ ì¡°ì •) ==== */
    const ANGLE_CALIB = {
        x: { offset: 0,  dir: 1 },
        y: { offset: 0,  dir: 1 },
        z: { offset: 90, dir: -1 }   // ìš”ì²­í•˜ì‹  ê°’ ìœ ì§€
    };

    /* ==== Zì¶• ì—°ì†ê°(unwrap)ìš© ì „ì—­ ìƒíƒœ ==== */
    let lastZRaw = null;
    let cumZRaw  = 0;

    /* ====================== ê¸°ë³¸ ì„¸íŒ… ====================== */
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f0f12);

    const camera = new THREE.PerspectiveCamera(45,1,0.01,50);
    // ì „ì²´ í”„ë ˆì„ ê¸°ì¤€ìœ¼ë¡œ ì ë‹¹íˆ ë³´ëŠ” ìœ„ì¹˜
    const maxDim = Math.max(SIZE_X + FRAME_THICK*2, SIZE_Y + FRAME_THICK + EXTRA_TOP, SIZE_Z);
    camera.position.set(maxDim*1.4, maxDim*1.4, maxDim*1.4);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    // íƒ€ê²Ÿì€ ë‚´ë¶€ ì‘ì—…ì˜ì—­ ì¤‘ì•™
    controls.target.set(SIZE_X/2, SIZE_Y/2, SIZE_Z/2);
    controls.update();
    controls.minDistance = maxDim * 0.2;
    controls.maxDistance = maxDim * 3;
    controls.screenSpacePanning = true;

    scene.add(new THREE.AmbientLight(0xffffff,0.6));
    const dir = new THREE.DirectionalLight(0xffffff,0.9);
    dir.position.set(2,3,2);
    scene.add(dir);

    // ë°”ë‹¥ ê·¸ë¦¬ë“œ (X-Z í‰ë©´, zâ‰ˆ0, y=0)
    const grid = new THREE.GridHelper(TARGET_MAX * 2, 40, 0x34495e,0x263238);
    grid.position.set(SIZE_X/2, 0, 0);
    scene.add(grid);

    /* ====================== ì¬ì§ˆ/ìœ í‹¸ ====================== */
    const matFrame = new THREE.MeshStandardMaterial({color:0x6b778c, metalness:0.2, roughness:0.75});
    const matRail  = new THREE.MeshStandardMaterial({color:0x9aa5b1, metalness:0.2, roughness:0.8});
    const matCart  = new THREE.MeshStandardMaterial({color:0x7d8a97, metalness:0.25, roughness:0.7});
    const matHead  = new THREE.MeshStandardMaterial({color:0xff9800, metalness:0.2, roughness:0.6});
    const matCone  = new THREE.MeshStandardMaterial({color:0x00bcd4, metalness:0.1, roughness:0.7, transparent:true, opacity:0.25});

    // ë¹” ìœ í‹¸
    function makeBeam(len, axis='x', size=FRAME_THICK, mat=matFrame){
        const g = axis==='x'
            ? [len,size,size]
            : axis==='y'
            ? [size,len,size]
            : [size,size,len];
        return new THREE.Mesh(new THREE.BoxGeometry(...g), mat);
    }

    /* ====================== í”„ë ˆì„ ====================== */
    const frame = new THREE.Group(); scene.add(frame);

    // 1) í•˜ë¶€ í”„ë ˆì„ (X/Z ì‚¬ê°) â€” ë°”ë‹¥ ìœ„ë¡œ FRAME_THICK/2 ë§Œí¼ (ë°”ë‹¥ì— ë”± ë¶™ê²Œ ë³´ì„)
    (() => {
        const s = FRAME_THICK;
        const bottomY = s/2;  // y=0~s ì˜ì—­ì— ìœ„ì¹˜ (ë°”ë‹¥ ì•ˆ ëš«ê³  ì˜¬ë¼ì™€ ìˆìŒ)

        const g = new THREE.Group();
        // X ë°©í–¥ ë¹”: ë‚´ë¶€ SIZE_X ê¸¸ì´ì— ì–‘ìª½ ì—¬ìœ  FRAME_THICKì”©
        const fxFront = makeBeam(SIZE_X + s*2,'x', s);
        fxFront.position.set(SIZE_X/2, bottomY, 0);

        const fxBack  = makeBeam(SIZE_X + s*2,'x', s);
        fxBack.position.set(SIZE_X/2, bottomY, SIZE_Z);

        // Z ë°©í–¥ ë¹”
        const fzLeft  = makeBeam(SIZE_Z,'z', s);
        fzLeft.position.set(-s, bottomY, SIZE_Z/2);

        const fzRight = makeBeam(SIZE_Z,'z', s);
        fzRight.position.set(SIZE_X + s, bottomY, SIZE_Z/2);

        g.add(fxFront,fxBack,fzLeft,fzRight);
        frame.add(g);
    })();

    // 2) ê¸°ë‘¥(ì„¸ë¡œ ë¹”) â€” í•˜ë¶€(s/2) ~ ìƒë¶€(SIZE_Y + s/2 + EXTRA_TOP)ê¹Œì§€ ë” ê¸¸ê²Œ
    (() => {
        const s = FRAME_THICK;
        const yBottom = s/2;                             // í•˜ë¶€ í”„ë ˆì„ ì¤‘ì‹¬
        const yTop    = SIZE_Y + s/2 + EXTRA_TOP;        // ìƒë¶€ í”„ë ˆì„ì„ EXTRA_TOPë§Œí¼ ë” ì˜¬ë¦° ìœ„ì¹˜
        const colLen  = yTop - yBottom;                  // ê¸°ë‘¥ ì‹¤ì œ ê¸¸ì´
        const centerY = (yBottom + yTop) / 2;            // ì¤‘ì•™ ìœ„ì¹˜

        const g = new THREE.Group();

        const cyFL = makeBeam(colLen,'y', s);
        cyFL.position.set(-s, centerY, 0);

        const cyFR = makeBeam(colLen,'y', s);
        cyFR.position.set(SIZE_X + s, centerY, 0);

        const cyBL = makeBeam(colLen,'y', s);
        cyBL.position.set(-s, centerY, SIZE_Z);

        const cyBR = makeBeam(colLen,'y', s);
        cyBR.position.set(SIZE_X + s, centerY, SIZE_Z);

        g.add(cyFL,cyFR,cyBL,cyBR);
        frame.add(g);
    })();

    // 3) ìƒë¶€ í”„ë ˆì„ (X/Z ì‚¬ê°) â€” ë‚´ë¶€ ì‘ì—…ì˜ì—­ ìœ„ìª½ìœ¼ë¡œ FRAME_THICK/2 + EXTRA_TOP ë§Œí¼ ì˜¬ë¦¼
    (() => {
        const s = FRAME_THICK;
        const topY = SIZE_Y + s/2 + EXTRA_TOP;   // ë‚´ë¶€ Y ìœ„ë¡œ s/2 + EXTRA_TOP ì˜¬ë¦¼

        const g = new THREE.Group();

        const txFront = makeBeam(SIZE_X + s*2,'x', s);
        txFront.position.set(SIZE_X/2, topY, 0);

        const txBack  = makeBeam(SIZE_X + s*2,'x', s);
        txBack.position.set(SIZE_X/2, topY, SIZE_Z);

        const tzLeft  = makeBeam(SIZE_Z,'z', s);
        tzLeft.position.set(-s, topY, SIZE_Z/2);

        const tzRight = makeBeam(SIZE_Z,'z', s);
        tzRight.position.set(SIZE_X + s, topY, SIZE_Z/2);

        g.add(txFront,txBack,tzLeft,tzRight);
        frame.add(g);
    })();

    /* ====================== ì´ë™ì¶• ê·¸ë£¹ ====================== */
    const groupY = new THREE.Group();
    const groupX = new THREE.Group();
    const groupZ = new THREE.Group();
    scene.add(groupY);
    groupY.add(groupX);
    groupX.add(groupZ);

    // X ë ˆì¼ (í•˜ë¶€ í”„ë ˆì„ ìœ„, ì¡°ê¸ˆ ë„ì›€)
    const xRail = makeBeam(SIZE_X+0.02,'x',0.02,new THREE.MeshStandardMaterial({color:0xD1A50B}));
    xRail.position.set(SIZE_X/2, FRAME_THICK + 0.01, SIZE_Z);
    groupY.add(xRail);

    // Z ë ˆì¼: X=0 ê¸°ì¤€, ì›€ì§ì´ëŠ” ê¸¸ì´(3500mm * 2ë°° ì‹œê°í™”)ì— ë”± ë§ê²Œ
    const xOffsetZrail = 0;
    const Z_RAIL_THICK = 0.02;

    const zRailBottom = makeBeam(RAIL_LEN_M,'z',Z_RAIL_THICK,matRail);
    zRailBottom.position.set(xOffsetZrail, FRAME_THICK + 0.03, RAIL_LEN_M);
    groupX.add(zRailBottom);

    const zRailTop = makeBeam(RAIL_LEN_M,'z',Z_RAIL_THICK,new THREE.MeshStandardMaterial({color:0x6bd1a3}));
    zRailTop.position.set(xOffsetZrail, FRAME_THICK + 0.045, RAIL_LEN_M);
    groupZ.add(zRailTop);

    // ìºë¦¬ì§€(ë² ì´ìŠ¤) - ë ˆì¼ ì‹œì‘ì (z=0) ê¸°ì¤€, zëŠ” 0ì—ì„œ ì‹œì‘
    const carriage = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.06,0.02),matCart);
    carriage.position.set(xOffsetZrail, FRAME_THICK + 0.045, RAIL_LEN_M + RAIL_Z_CENTER);
    groupZ.add(carriage);

    // ì•”(armBase) ê¸°ì¤€ì 
    const armBase = new THREE.Group();
    armBase.position.copy(carriage.position);
    groupZ.add(armBase);

    /* ====================== ì•”/ê´€ì ˆ ====================== */
    const L2_LEN = LINK_L2;
    const linkL2 = new THREE.Mesh(
        new THREE.BoxGeometry(L2_THICK, L2_THICK, L2_THICK),
        new THREE.MeshStandardMaterial({color:0x9E9E9E})
    );
    linkL2.position.set(0, 0, L2_THICK/2);
    armBase.add(linkL2);

    const jointZEnd = new THREE.Group();
    jointZEnd.position.set(0, 0, L2_LEN);
    armBase.add(jointZEnd);

    const plateHeight = LINK_L1 * 0.45;
    const plateZ = new THREE.Mesh(
        new THREE.BoxGeometry(L2_THICK, plateHeight, L2_THICK),
        new THREE.MeshStandardMaterial({color:0xB0BEC5})
    );
    plateZ.position.set(0, plateHeight/3, -L2_THICK);
    jointZEnd.add(plateZ);

    const jointY = new THREE.Group();
    jointY.position.set(0, plateHeight, 0);
    jointZEnd.add(jointY);

    const L1_LEN = LINK_L1;
    const linkL1 = new THREE.Mesh(
        new THREE.BoxGeometry(L1_THICK, L1_LEN, L1_THICK),
        new THREE.MeshStandardMaterial({color:0x8BC34A})
    );
    linkL1.position.set(0, L1_LEN/3, 0);
    jointY.add(linkL1);

    const jointX = new THREE.Group();
    jointX.position.set(0, L1_LEN, 0);
    jointY.add(jointX);

    /* ====================== ì¹´ë©”ë¼ í—¤ë“œ ====================== */
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.08,0.08), matHead);
    head.position.set(0,0.007,0.05);
    jointX.add(head);

    const topStripe = new THREE.Mesh(
        new THREE.BoxGeometry(0.072, 0.004, 0.072),
        new THREE.MeshStandardMaterial({color: 0xff1744, metalness:0.2, roughness:0.6})
    );
    topStripe.position.set(0, -0.08/2 - 0.002, 0);
    head.add(topStripe);

    const upArrow = new THREE.ArrowHelper(
        new THREE.Vector3(0, -1, 0),
        new THREE.Vector3(0, 0, 0),
        0.10,
        0xff1744,
        0.02, 0.01
    );
    head.add(upArrow);

    const lensMat = new THREE.MeshStandardMaterial({color:0x222831, metalness:0.6, roughness:0.4});
    const lensBody = new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.03,0.04,32), lensMat);
    lensBody.rotation.x = Math.PI/2;
    lensBody.position.set(0,0,0.06);
    head.add(lensBody);

    const glassMat = new THREE.MeshStandardMaterial({color:0x2196f3, transparent:true, opacity:0.6});
    const glass = new THREE.Mesh(new THREE.CircleGeometry(0.023,32), glassMat);
    glass.rotation.x = Math.PI/2;
    glass.position.set(0,0,0.08);
    head.add(glass);

    const fovDeg=50, coneLen=0.25;
    const coneRadius = Math.tan(deg2rad(fovDeg/2))*coneLen;
    const cone = new THREE.Mesh(new THREE.ConeGeometry(coneRadius,coneLen,24,1,true), matCone);
    cone.rotation.x = Math.PI/2;
    cone.position.set(0,0,0.06 + coneLen*0.8);
    head.add(cone);

    const backMat = new THREE.MeshStandardMaterial({color:0xB0BEC5, metalness:0.4, roughness:0.7});
    const backBox = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.06,0.05), backMat);
    backBox.position.set(0, 0, -0.05);
    head.add(backBox);

    /* ====================== í¬ì¦ˆ ì—…ë°ì´íŠ¸ ====================== */
    const poseText = document.getElementById('poseText');

    window.updateRobotPose = (pose)=>{
        // ìœ„ì¹˜(mm) - ì‹¤ì œ ë²”ìœ„ë¡œ í´ë¨í”„
        const xIn = clamp(pose.x ?? 0, 0, RAW_X_MM);
        const yIn = clamp(pose.y ?? 0, 0, RAW_Y_MM);
        const zIn = clamp(pose.z ?? 0, 0, RAW_Z_WORK_MM);

        // ì”¬ ì¢Œí‘œ(m)
        const xM = xIn * MM_TO_M * SCENE_SCALE;
        const yM = yIn * MM_TO_M * SCENE_SCALE;
        const zM = zIn * MM_TO_M * SCENE_SCALE * Z_VISUAL_SCALE; // 2ë°° ì‹œê°í™”

        groupY.position.set(0, yM, 0);
        groupX.position.set(xM, 0, 0);
        groupZ.position.set(0, 0, zM);

        // ê°ë„ ì…ë ¥ (Raw, HUDìš©)
        const xRaw = clamp(Number(pose.s3 ?? 0), 0, 180);
        const yRaw = clamp(Number(pose.s2 ?? 0), 0, 180);
        const zRaw = ((Number(pose.s1 ?? 0) % 360) + 360) % 360;

        const xPrimeIn = xRaw;
        const yPrimeIn = yRaw;
        const zPrimeIn = zRaw;

        // Zì¶• ì—°ì†ê°(unwrap)
        if (lastZRaw === null) {
            cumZRaw = zRaw;
        } else {
            let dz = zRaw - lastZRaw;
            if (dz > 180)  dz -= 360;
            if (dz < -180) dz += 360;
            cumZRaw += dz;
        }
        lastZRaw = zRaw;

        let zHud = ((cumZRaw % 360) + 360) % 360;
        if (zHud === 0 && Math.abs(cumZRaw) > 1e-6) zHud = 360;

        // ë³´ì • ì ìš©
        const xAdj = (xRaw    - ANGLE_CALIB.x.offset) * ANGLE_CALIB.x.dir;
        const yAdj = (yRaw    - ANGLE_CALIB.y.offset) * ANGLE_CALIB.y.dir;
        const zAdj = (cumZRaw - ANGLE_CALIB.z.offset) * ANGLE_CALIB.z.dir;

        const xAdjClamped = clamp(xAdj, 0, 180);
        const yAdjClamped = clamp(yAdj, 0, 180);
        const zAdjNorm    = ((zAdj % 360) + 360) % 360;

        let zPhys = ((180 - zAdjNorm) % 360 + 360) % 360;
        if (zPhys === 0 && Math.abs(zAdj) > 1e-6) zPhys = 360;

        const xPhys = 180 - xAdjClamped;
        const yPhys = 180 - yAdjClamped;

        jointX.rotation.x    = THREE.MathUtils.degToRad(-xPhys);
        jointY.rotation.x    = THREE.MathUtils.degToRad( yPhys);
        jointZEnd.rotation.z = THREE.MathUtils.degToRad( zPhys);

        poseText.textContent =
            `x:${Math.round(xIn)}  y:${Math.round(yIn)}  z:${Math.round(zIn)}  ` +
            `s1:${zHud.toFixed(0)}Â°  s2:${yPrimeIn.toFixed(0)}Â°  s3:${xPrimeIn.toFixed(0)}Â°`;
    };

    /* ====================== ë Œë” ë£¨í”„ ====================== */
    function resize(){
        const w=canvas.clientWidth,h=canvas.clientHeight;
        if(renderer.domElement.width!==w||renderer.domElement.height!==h){
            renderer.setSize(w,h,false);
            camera.aspect=w/h;
            camera.updateProjectionMatrix();
        }
    }
    function animate(){
        requestAnimationFrame(animate);
        resize();
        controls.update();
        renderer.render(scene,camera);
    }
    animate();

    window.onStateUpdate = function(msg) {
        try {
            const pose = JSON.parse(msg);
            if (pose) window.updateRobotPose(pose);
        } catch (e) {
            console.error("StateUpdate íŒŒì‹± ì˜¤ë¥˜:", e, msg);
        }
    };
    // í…ŒìŠ¤íŠ¸
    //window.updateRobotPose({ x:15000, y:44000, z:3500, s1:0, s2:0, s3:90 });
</script>
</body>
</html>
